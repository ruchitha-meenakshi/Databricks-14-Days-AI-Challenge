# Day 6: Medallion Architecture (Bronze-Silver-Gold) üèÖ

**Challenge:** [Databricks 14-Day AI Challenge](https://www.linkedin.com/feed/hashtag/?keywords=databrickswithidc)  
**Topic:** Designing a Multi-Hop Architecture  
<img width="600" height="1350" alt="6 (1)" src="https://github.com/user-attachments/assets/8ef1a8e8-b864-4683-8eed-e25139c51688" />


![Databricks](https://img.shields.io/badge/Databricks-FF3621?style=for-the-badge&logo=databricks&logoColor=white)
![Apache Spark](https://img.shields.io/badge/Apache%20Spark-E25A1C?style=for-the-badge&logo=apachespark&logoColor=white)
![Codebasics](https://img.shields.io/badge/Codebasics-F7931E?style=for-the-badge)
![Indian Data Club](https://img.shields.io/badge/Indian_Data_Club-4CAF50?style=for-the-badge)  
![Status](https://img.shields.io/badge/Status-Completed-green?style=for-the-badge)
---

## Deep Dive: The Medallion Architecture

The Medallion Architecture (or "Multi-Hop" architecture) is the industry standard for building Data Lakehouses. It organizes data quality into three distinct levels, ensuring that raw data is preserved while business-ready data is highly optimized.

**The Flow:** `Bronze (Raw)` ‚Üí `Silver (Cleaned)` ‚Üí `Gold (Aggregated)`

### 1. ü•â Bronze Layer (Raw Ingestion)
**Purpose:** The landing zone. Its job is to capture data from external source systems (APIs, Databases, IoT logs) as quickly and faithfully as possible.

* **Best Practices:**
    * **"As-Is" Storage:** Do not correct typos, change data types, or drop columns. If the source system sends garbage, store the garbage. This ensures you have an immutable record of history.
    * **Append-Only:** New data is constantly appended. Do not overwrite history.
    * **Metadata:** Add columns like _ingestion_timestamp and _source_file to track lineage and debug issues later.
* **Incremental Pattern:**
    * Use tools like **Auto Loader** `(cloudFiles)` or `COPY INTO` to detect only new files landing in cloud storage and ingest them efficiently without listing the entire directory.

### 2. ü•à Silver Layer (Cleaned & Enriched)
**Purpose:** The "Enterprise Truth." This layer validates, cleans, and structures the data so it can be trusted by the entire organization.

* **Best Practices:**
    * **Data Quality Checks:** Filter out corrupt records (e.g., `price < 0`), handle null values, and strictly enforce schema types (String ‚Üí Date).
    * **Deduplication:** Remove duplicate records that may have been generated by source system retries.
    * **Enrichment:** Join with static reference tables (e.g., adding `Product Name` to a `Product ID`) to make the data more readable.
* **Incremental Pattern:**
    * **Upserts (MERGE):** Instead of rewriting the whole table, use the `Delta MERGE` command. This matches incoming Bronze records with existing Silver records to update modified rows and insert new ones (Handling CDC - Change Data Capture).

### 3. ü•á Gold Layer (Business Aggregates)
**Purpose:** The consumption layer. Data here is pre-calculated and optimized for dashboards (PowerBI, Tableau) and Machine Learning models.

* **Best Practices:**
    * **Read-Optimized:** Use **Dimensional Modeling** (Star Schema). Create Fact tables (transactions) and Dimension tables (context).
    * **Pre-Aggregation:** Calculate heavy metrics (e.g., "Monthly Revenue by Region") here, so the BI tool doesn't have to compute them on the fly.
    * **Business Terminology:** Rename columns to business-friendly terms (e.g., cust_id ‚Üí Customer Name).
* **Incremental Pattern:**
    * **Materialized Views:** For massive datasets, only re-calculate the aggregates for the changed data partitions.
    * **Complete Overwrite:** For smaller aggregate tables (e.g., "Top 10 Products"), it is often simpler to overwrite the table daily.

**Why this architecture works?**
* **Replayability:** If you find a bug in your Silver cleaning logic, you can simply delete Silver and re-run everything from Bronze (since Bronze is immutable).
* **Performance:** BI users query small, fast Gold tables instead of scanning massive raw logs.
* **Governance:** You can lock down PII (personally identifiable information) in the Silver layer while giving broad access to the anonymized aggregates in Gold.
---
## Code Implementation

##### 1. Bronze Layer (Raw Ingestion with Metadata)  
*Note: In Unity Catalog, we use the `_metadata` column to securely access file paths.*  
<img width="707" height="293" alt="Screenshot 2026-01-14 at 07 49 38" src="https://github.com/user-attachments/assets/13eba11b-6773-4266-98a9-c92048ecf3ef" />


##### 2. Silver Layer (Quality Enforcement)  
Cleaning data by removing negative prices and duplicates.  
<img width="709" height="479" alt="Screenshot 2026-01-14 at 07 50 03" src="https://github.com/user-attachments/assets/5a17a577-5b21-49c3-9c21-76bd3293af16" />


##### 3. Gold Layer (Aggregates & Safe Division)  
Calculating Conversion Rate with safety checks for Divide-by-Zero errors.
<img width="943" height="565" alt="Screenshot 2026-01-14 at 07 59 03" src="https://github.com/user-attachments/assets/d89f7b1e-dc1f-4370-b3bc-0b6faab70e9a" />

---
## ‚úÖ Tasks Completed
- [x] **Designed 3-Layer Architecture:** Configured physical paths for Bronze, Silver, and Gold.
- [x] **Built Bronze:** Ingested raw Parquet data and captured lineage metadata.
- [x] **Built Silver:** Cleaned data (deduplication, filters) and enriched schema.
- [x] **Built Gold:** Created business-ready aggregates (Revenue & Conversion Rate).

---
## üìÇ Repository Structure

* **`Day 6 - Medallion Architecture.ipynb `**
    The Architecture Design notebook: Implements a full end-to-end pipeline moving data from Raw Ingestion (Bronze) to Cleaned Truth (Silver) and finally Business Aggregates (Gold).
